from decimal import Decimal, getcontext
import numpy as np
from numba import cuda
import math
from PIL import Image
@cuda.jit
def add_chunks_kernel(a, b, result, temp, digits):
        if(a[0] == b[0]):
            temp[0] = a[0]
            for i in range(digits, 0, -1):
                temp[i] += a[i] + b[i]
                if(temp[i] >= 10):
                    temp[i - 1] += 1
                    temp[i] -= 10
                    
        greater_abs = 0
        for i in range(1, digits):
            if (a[i] > b[i]):
                break
            if (b[i] > a[i]):
                greater_abs = 1
                break
        
        if (a[0] == 1 and b[0] == 0):
            if (greater_abs == 0):
                temp[0] = 1
                for i in range(digits, 0, -1):
                    temp[i] += a[i] - b[i]
                    if(temp[i] < 0):
                        temp[i - 1] -= 1
                        temp[i] += 10
            if (greater_abs == 1):
                temp[0] = 0
                for i in range(digits, 0, -1):
                    temp[i] += b[i] - a[i]
                    if(temp[i] < 0):
                        temp[i - 1] -= 1
                        temp[i] += 10
                        
        if (a[0] == 0 and b[0] == 1):
            if (greater_abs == 0):
                temp[0] = 0
                for i in range(digits, 0, -1):
                    temp[i] += a[i] - b[i]
                    if(temp[i] < 0):
                        temp[i - 1] -= 1
                        temp[i] += 10
            if (greater_abs == 1):
                temp[0] = 1
                for i in range(digits, 0, -1):
                    temp[i] += b[i] - a[i]
                    if(temp[i] < 0):
                        temp[i - 1] -= 1
                        temp[i] += 10
        
        for i in range(0, digits):
            result[i] = temp[i]
        
        for i in range(0, (digits * 2) + 1):
            temp[i] = 0

@cuda.jit
def multiply_chunks_kernel(a, b, result, temp, digits):
        if (a[0] == b[0]):
            result[0] = 0
        else:
            result[0] = 1
        
        for i in range(0, digits):
            for j in range(0, digits):
                temp[i + j] += a[i + 1] * b[j + 1]
        
        for i in range(digits * 2, 0, -1):
            if(temp[i] >= 10):
                temp[i - 1] += temp[i] / 10
                temp[i] %= 10
                
        for i in range(0, digits):
            result[i + 1] = temp[i]
        
        for i in range(0, (digits * 2) + 1):
            temp[i] = 0

@cuda.jit
def reset_array(arr, digits):
    for i in range(0, digits):
        arr[i] = 0
        
@cuda.jit
def copy_array(a, b, digits):
    for i in range(0, digits):
        a[i] = b[i]
@cuda.jit 
def mandelbrot_single_point(imag_values, real_values, image, res, z_real, z_imag, z_real2, z_imag2, new_z_real, new_z_imag, negative1, two, result, temp, digits, max_iterations):
    if cuda.grid(1) == 0:
        for i in range(res):
            for j in range(res):
                reset_array(z_real, digits)
                reset_array(z_imag, digits)
                for k in range(max_iterations + 1):
                    
                    if(k == max_iterations):
                        image[i][j] = k
                        break
                    
                    multiply_chunks_kernel(z_real, z_real, z_real2, temp, digits)
                    multiply_chunks_kernel(z_imag, z_imag, z_imag2, temp, digits)
                    
                    add_chunks_kernel(z_real2, z_imag2, result, temp, digits)
                    
                    magnitude_squared = result[1]
                    if (magnitude_squared >= 4):
                        image[i][j] = k
                        break
                    reset_array(result, digits)
                    multiply_chunks_kernel(z_imag2, negative1, result, temp, digits)
                    add_chunks_kernel(z_real2, result, result, temp, digits)
                    add_chunks_kernel(result, real_values[i][j], new_z_real, temp, digits)
                    reset_array(result, digits)
                    
                    multiply_chunks_kernel(two, z_real, result, temp, digits)
                    multiply_chunks_kernel(result, z_imag, result, temp, digits)
                    add_chunks_kernel(result, imag_values[i][j], new_z_imag, temp, digits)
                    
                    copy_array(z_real, new_z_real, digits)
                    copy_array(z_imag, new_z_imag, digits)
                    
                    # Reset result for next iteration
                    reset_array(result, digits)
                    reset_array(z_real2, digits)
                    reset_array(z_imag2, digits)
                    reset_array(new_z_real, digits)
                    reset_array(new_z_imag, digits)
                
                
def generate_mandelbrot(center_x, center_y, zoom, res, max_iterations, digits):
    image = np.zeros((res, res), dtype=np.int32)
    real_values = np.zeros((res, res, digits + 1))
    imag_values = np.zeros((res, res, digits + 1))
    
    real_values, imag_values = set_pixels(center_x, center_y, real_values, imag_values, zoom, res, digits)
    
    result = np.zeros(digits + 1, dtype=np.int32)
    z_real = np.zeros(digits + 1, dtype=np.int32)
    z_imag = np.zeros(digits + 1, dtype=np.int32)
    z_real2 = np.zeros(digits + 1, dtype=np.int32)
    z_imag2 = np.zeros(digits + 1, dtype=np.int32)
    new_z_real = np.zeros(digits + 1, dtype=np.int32)
    new_z_imag = np.zeros(digits + 1, dtype=np.int32)
    temp = np.zeros(digits * 2, dtype=np.int32)
    
    negative1 = np.zeros(digits + 1, dtype=np.int32)
    negative1[0] = 1
    negative1[1] = 1
    
    two = np.zeros(digits + 1, dtype=np.int32)
    two[1] = 2
    
    threads_per_block = 256
    blocks_per_grid = (len(result) + (threads_per_block - 1)) // threads_per_block
    
    mandelbrot_single_point[blocks_per_grid, threads_per_block](imag_values, real_values, image, res, z_real, z_imag, z_real2, z_imag2, new_z_real, new_z_imag, negative1, two, result, temp, digits, max_iterations)
    return image

def set_pixels(center_x_str, center_y_str, real_values, imag_values, zoom_str, res, digits):

    getcontext().prec = digits * 2
    precision = Decimal('1e-100') 
    
    # Convert input strings to Decimal
    center_x = Decimal(center_x_str)
    center_y = Decimal(center_y_str) * -1
    zoom = Decimal(zoom_str)
    
    # Calculate pixel size and minimum coordinates
    pixel_size = Decimal(3.0) * zoom / Decimal(res)
    minX = center_x - (pixel_size * Decimal(res) / Decimal(2))
    minY = center_y - (pixel_size * Decimal(res) / Decimal(2))
    
    # Initialize grids
    real_values = [[None for _ in range(res)] for _ in range(res)]
    imag_values = [[None for _ in range(res)] for _ in range(res)]
    
    # Fill grids
    for i in range(res):
        for j in range(res):
            x = minX + (Decimal(i) * pixel_size)
            y = minY + (Decimal(j) * pixel_size)
            x = '{:.50f}'.format(x)
            y = '{:.50f}'.format(y)
            real_values[j][i] = to_chunks(str(x), digits)
            imag_values[j][i] = to_chunks(str(y), digits)

    real_values = np.array(real_values)
    imag_values = np.array(imag_values)

    return real_values, imag_values
def to_chunks(number, num_digits):
    number_str = number.replace('.', '')
    if number_str[0] == '-':
        number_str = number_str.replace('-', '1')
    else:
        number_str = '0' + number_str[0:]
    required_length = num_digits + 1
    
    # Pad number_str with zeros if it's shorter than required_length
    if len(number_str) < required_length:
        number_str = number_str.ljust(required_length, '0')
    else:
        # Truncate number_str to required_length if it's longer
        number_str = number_str[:required_length]
    
    int_array = []
    for i in range(0, required_length):
        num = int(number_str[i])
        int_array.append(num)
    
    return int_array

def remove_trailing_zeros(s):
    i = len(s) - 1
    while i >= 0 and s[i] == '0':
        i -= 1
    
    if i >= 0:
        return s[:i + 1]
    else:
        return s 

def chunks_to_decimal(arr):
    digits = ''.join(str(digit) for digit in arr)
    number_str = digits[1] + '.' + digits[2:]
    number_str = remove_trailing_zeros(number_str)
    if digits[0] == '0':
        return number_str
    else:
        return '-' + number_str

def array_to_image(array, max_value):
    # Convert the array to a binary image (black and white)
    # Pixels will be black if their value equals threshold, otherwise white
    height, width = array.shape
    image_data = np.zeros((height, width), dtype=np.uint8)  # Initialize an array for the image

    # Set pixels to 255 (white) or 0 (black)
    image_data[array == max_value] = 0     # Black
    image_data[array != max_value] = 255   # White

    # Create and save the image
    img = Image.fromarray(image_data, 'L')  # 'L' mode is for grayscale
    img.save('output_image.png')
    
# main operating portion

num_digits = 16
center_x = '-1.0'
center_y = '0.0'
zoom     = '0.5'

res = 256
max_iterations = 25

result = generate_mandelbrot(center_x, center_y, zoom, res, max_iterations, num_digits)

print(result)
array_to_image(result, max_iterations)